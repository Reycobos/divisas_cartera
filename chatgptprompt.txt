PROMPT (cópialo tal cual)

Quiero que generes un adapter Python para integrar un nuevo exchange en mi dashboard de estrategias delta-neutral, respetando al milímetro los contratos ya usados por mi front y backend. Razona en privado y entrégame solo resultados concretos (código, diffs, tests y pasos). No muestres cadena de pensamiento.

Contexto real (ficheros/contratos existentes que debes cumplir)

Front indexv4.6.html:

La pestaña Balances pinta por exchange: spot, margin, futures, más equity y unrealized_pnl. El JSON lo saca de GET /api/balances y usa exactamente estas claves. 

indexv4.6

La pestaña Open Positions espera por fila: exchange, symbol, side, size, entry_price, mark_price, liquidation_price, notional, unrealized_pnl, fee, funding_fee, realized_pnl. 

indexv4.6

La pestaña Closed consume GET /api/closed_positions; cada leg trae fees y funding_fee (alias de DB). El “PnL” mostrado en la tabla es solo precio (el front lo recalcula con close-entry y size). El “Realized” mostrado es el total neto (precio + fees + funding) que debe venir desde la DB en realized_pnl. 

indexv4.6

DB db_manager.py:

Tabla closed_positions con columnas: realized_pnl, funding_total, fee_total (las fees se normalizan siempre negativas en save_closed_position). 

db_manager

Ruta /api/closed_positions (servidor):

Cuando lee de DB hace SELECT ..., realized_pnl, funding_total AS funding_fee, fee_total AS fees, ... y el front consume fees/funding_fee. Mantén este shape. (Ya está implementado en mi servidor).

Toggles (servidor):

SYNC_ALL / SYNC_EXCHANGES con should_sync(exchange) para guardar cerradas.

BALANCE_ALL / BALANCE_EXCHANGES con should_fetch_balance(exchange) para pedir balances. (Respeta estos toggles al integrar).

Objetivo

Crear adapters/<exchange_slug>.py con estas funciones públicas (expórtalas en __all__):

fetch_<exchange>_open_positions(...)

fetch_<exchange>_funding_fees(limit: int = 50, ...)

fetch_<exchange>_all_balances(...) ← Debe mapear Spot/Margin/Futures como lo pinta el HTML (ver “Balances” abajo).

save_<exchange>_closed_positions(db_path: str = "portfolio.db", ...) ← Guarda en SQLite usando save_closed_position(...).

No crees rutas Flask aquí. El servidor principal ya las usa.

Reglas de datos y cálculo (obligatorias)

A) Normalización de símbolo (usar SIEMPRE):

import re
def normalize_symbol(sym: str) -> str:
    if not sym: return ""
    s = sym.upper()
    s = re.sub(r'^PERP_', '', s)
    s = re.sub(r'(_|-)?(USDT|USDC|PERP)$', '', s)  # quita sufijos y separador previo
    s = re.sub(r'[_-]+$', '', s)                   # guiones finales
    s = re.split(r'[_-]', s)[0]                    # primera parte limpia (KAITO_USDC -> KAITO)
    return s


B) Open positions — shape EXACTO (por fila) (lo que el front lee): 

indexv4.6

{
  "exchange": "<exchange_slug>",
  "symbol": "<normalize_symbol>",
  "side": "long" | "short",
  "size": float,
  "entry_price": float,
  "mark_price": float,
  "liquidation_price": float | 0.0,
  "notional": float,
  "unrealized_pnl": float,    // SOLO precio = (mark - entry) * size (ajusta por side)
  "fee": float,               // acumulado de fees; NEGATIVO si es costo
  "funding_fee": float,       // + cobro / - pago
  "realized_pnl": float       // = fee + funding_fee (solo abiertas)
}


En abiertas, “Realized PnL” del front es fees + funding (no incluye precio).

C) Funding history — shape EXACTO (por fila):

{
  "exchange": "<exchange_slug>",
  "symbol": "<normalize_symbol>",
  "income": float,        // + cobro / - pago
  "asset": "USDT"|"USDC"|"USD",
  "timestamp": int,       // epoch ms
  "funding_rate": float | 0.0,
  "type": "FUNDING_FEE"
}


D) Balances — estructura EXACTA (front Balances): 

indexv4.6


Tu fetch_<exchange>_all_balances(...) debe devolver un único dict con:

{
  "exchange": "<exchange_slug>",
  "equity": float,
  "balance": float,           // saldo utilizable total
  "unrealized_pnl": float,    // 0.0 si no aplica
  "initial_margin": float | 0.0,
  "spot": float | 0.0,        // SOLO spot
  "margin": float | 0.0,      // SOLO margin
  "futures": float | 0.0      // SOLO derivados/futuros
}


NO mezcles buckets. Si el exchange no tiene margin o spot, pon 0.0. El front muestra por exchange:

Spot → b.spot

Margin → b.margin

Futures → b.futures

Total Equity → b.equity

PnL No Realizado → b.unrealized_pnl
(Esto está cableado en el HTML). 

indexv4.6

E) Closed positions → persistencia en SQLite (save_closed_position)
Guarda por fila (tabla closed_positions): 

db_manager

{
  "exchange": "<exchange_slug>",
  "symbol": "<normalize_symbol>",
  "side": "long"|"short"|"closed",
  "size": float,
  "entry_price": float,
  "close_price": float,
  "open_time": int,          // epoch s
  "close_time": int,         // epoch s
  "realized_pnl": float,     // **TOTAL NETO** = precio + fees + funding (esto es lo que el front pinta como "Realized")
  "funding_total": float,    // funding acumulado (+/-)
  "fee_total": float,        // **siempre negativa** (costo)
  "notional": float,
  "leverage": float | null,
  "liquidation_price": float | null
}


En cerradas, el front mostrará:

PnL (tabla) = solo precio (lo recalcula él con close-entry y size).

Fees = fees (que viene de tu fee_total).

Funding = funding_fee (alias de funding_total).

Realized = realized_pnl (neto).
La ruta ya aliasa funding_total AS funding_fee y fee_total AS fees. Tú solo guarda bien.

F) Fórmulas y signos (clave):

Convención:
pnl_neto = price_pnl + funding_total + fee_total con fee_total negativo.
⇒ price_pnl = pnl_neto - funding_total - fee_total

Abiertas:
unrealized_pnl = (mark - entry) * size (ajusta signo por side).
realized_pnl (open) = fee_total + funding_total (fees negativas + funding +/-).

Cerradas:
realized_pnl (DB) = pnl_neto (lo que da la API como neto).
Para size cuando haga falta reconstruirlo:
size = |price_pnl| / |close - entry| con fallback por ROE/leverage si close≈entry.

Calidad de código del adapter

Archivo completo adapters/<exchange_slug>.py con:

__all__ exponiendo las 4 funciones.

Manejo robusto de floats/Decimal, backoff, paginación, límites de ventana de la API.

Normalización de símbolo con normalize_symbol.

Docstrings con endpoints y ejemplo de payload.

if __name__ == "__main__": con smoke tests (--dry-run por defecto).

Integración con el servidor (toggles)

Entrega diffs precisos para enchufar el exchange respetando mis toggles:

Sincronización de cerradas (usa should_sync(exchange)):

En el diccionario sync_functions de main() agrega:

"<exchange_slug>": lambda: save_<exchange_slug>_closed_positions("portfolio.db", debug=False)


No ejecutes si should_sync("<exchange_slug>") es False.

Pedir balances (usa should_fetch_balance(exchange)):

En main_balances() agrega al dict balance_functions:

"<exchange_slug>": lambda: fetch_<exchange_slug>_all_balances(db_path="portfolio.db")


Respeta el early-continue si should_fetch_balance("<exchange_slug>") es False.

Toggles:

Añade "<exchange_slug>": False en:

SYNC_EXCHANGES = { ... }
BALANCE_EXCHANGES = { ... }


Comentario: “cámbialo a True para activar”.

La ruta /api/balances debe seguir devolviendo:

return jsonify({
  "totals": { "equity": total_equity, "balance": total_balance, "unrealized_pnl": total_unreal },
  "exchanges": balances
})


No rompas este shape (el front itera data.exchanges con esos campos). 

indexv4.6

Debug & utilidades (inclúyelos en el adapter)

debug_preview_<exchange_slug>_closed(days=3, symbol=None)
Imprime exactamente lo que se guardaría (campos DB) y calcula price_pnl = realized_pnl - funding_total - fee_total para validar contra precios.

Script aparte debug_save_<exchange_slug>.py (en la raíz):

Fetch (preview), guardar en portfolio.db usando save_closed_position,

Leer últimas cerradas de ese exchange,

Simular el JSON de /api/closed_positions (alias funding_total AS funding_fee, fee_total AS fees) para ver lo mismo que el front.

Tests mínimos (pytest)

normalize_symbol() con casos raros.

Mapper de balances: colocar correctamente spot/margin/futures/equity/unrealized_pnl.

Cálculo de unrealized_pnl en abiertas y realized_pnl neto en cerradas.

Reconstrucción de size desde price_pnl y fallback por ROE/leverage.

Firmas/autenticación (mock) y paginación.

Entregables

adapters/<exchange_slug>.py completo (imports, __all__, código productivo, smoke tests, debug preview).

Diffs para el servidor (alta en sync_functions, main_balances(), y toggles).

Script debug_save_<exchange_slug>.py.

Ejemplos JSON para:

/api/balances (con los tres buckets por exchange, tal cual los usa el front),

/api/positions, /api/closed_positions, /api/funding.

Instrucciones de prueba (curl/HTTPie) y checklist de aceptación:

Front muestra Spot/Margin/Futures correctos,

Totales coherentes,

DB persiste cerradas con fee_total negativa y realized_pnl neto,

Ningún exchange existente se rompe.

Nota: respeta exactamente los nombres de claves y estructuras citadas del front/DB; el HTML ya depende de ellas. 

db_manager